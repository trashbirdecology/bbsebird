---
title: "Runthrough"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Runthrough}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r load-pkg}
devtools::install_github("trashbirdecology/dubcorms", force=FALSE)
library(dubcorms)

```
# Step 1: Setup and Specifications
## Specs for data subsetting
First, specify the species, regions, and time frames where necessary. 
```{r specs-subsetting}
## List out the various uses of the species names and abbreviations, just to be safe. 
interest.species <- c("DOCCOR", "DOCCO", "DCCO", "DCCOR", "Double-crested Cormorant", "Double Crested Cormorant") 

## List the countries of interest
countries <- c("Canada","USA", "United States", "United States of America") # used to create base maps

## Specify the regions you know you definitely don't want to use.
region.remove = c("Alaska", "Hawaii", "Northwest Territories", "Yukon", "Nunavut", "Yukon Territory") 

## Specify the states/provinces of interest.
states <- c("NY", "US-NY", "New York")

## Time frames
### range of years for subsetting observations
year.range <- c(2008:year(Sys.Date()))
### range of days of the year for subsetting ebird and bbs data 
min.yday <- 91  # approximate breeding season day start (day of year)
max.yday <- 245 # approximate breeding season day end (day of year)
```

```{r specs-directories}
## Create a shorthand name for the project
proj.shorthand="ny" # used to 
```

## BBS Data Specifications
The following specifications are for munging BBS data
```{r specs-bbs}
include.unid <- FALSE ## Whether or not to include UNIDENTIFIED // hybrid species
```


## eBird Data Specifications
The following specifications are for munging eBird data
```{r specs-ebird}
ebird.protocol <- c("Traveling", "Stationary")
complete.checklists.only <- TRUE
max.effort.mins <-  3*60 ## arbitrary
max.effort.km   <-  5 #This is coarse also, typically 5km or less
max.num.observers <- 10
mmyyyy <- "Oct-2021" # month and year of most recent ebird EBD/samp download in file.
```


## Geospatial specifications
```{r specs-geospatial}
## specify the target geographic or projected coordinate reference system (CRS)
crs.target <- 4326 # 4326 == unprojected; 5070=Alberts equal area (used by USGS)

## provide the desired grid cell size (units== decimal degrees)
### A good estimate for large-scale (>=state) studies in North Am.
#### is that there are 111.111km in 1 degree latitude or longitude
#### miles to km: km=1.61*miles
grid.size=.25 #== 1/4 deg
```

## Directory specifications and naming
```{r specs-dir-touch}
## Where is your original eBird data stored?
dir.ebird.in <- "C:/Users/jburnett/OneDrive - DOI/research/cormorants/dubcorm-data-backup/ebird"
## Where are the BBS route shapefiles stored?
cws.routes.dir <- "C:/Users/jburnett/OneDrive - DOI/research/cormorants/dubcorm-data-backup/bbs/route_shapefiles/cws"
usgs.routes.dir <- "C:/Users/jburnett/OneDrive - DOI/research/cormorants/dubcorm-data-backup/bbs/route_shapefiles/usgs"
```

```{r specs-dir-donottouch}
## automatically creates a new directory for storing munged data, results, figures, etc. based on project shorthand name. 
dir.proj.out <- paste0("vignettes/",proj.shorthand,"-example-", round(grid.size*111.111), "km/")
## where to store the JAGS objects
dir.jags <- paste0(dir.proj.out, "jags/")
dir.bbs.out <- paste0(dir.proj.out,"bbs/")
dir.ebird.out <- paste0(dir.proj.out,"ebird/")
dir.spatial.out <- paste0(dir.proj.out,"spatial/")
dir.plots <- paste0(dir.proj.out, "plots/")
sapply(c(dir.proj.out, dir.bbs.out, dir.ebird.out, dir.spatial.out, dir.jags, dir.plots), FUN=
         function(x) dir.create(x, showWarnings = FALSE))
args.save <- ls() # saves a list of elements we always want to keep in memory
```

# Step 2: Make a Spatial Grid
If the spatial grid R object, `grid.rds`, already exists in `r dir.proj.out`, load it into file. If not, will create a new spatial grid and save to file. 
```{r}
## If a grid.rds is saved in project directory, will not run script and instead will load that file into memory
## load in that rds.
if("grid.rds" %in% list.files(dir.spatial.out)) grid <- readRDS(paste0(dir.spatial.out, "/", "grid.rds"))else{
study.area <-
  ne_states(country = countries, returnclass = "sf") %>%
  # remove region(s)
  filter(tolower(name) %in% tolower(states)) %>%
  filter(!tolower(name) %in% tolower(region.remove)) %>%
  st_transform(study.area, crs = crs.target)
# unique(study.area$adm0_a3) #should add a test here to make sure number of countries expected is grabbed.

# throw a grid over the study area layer
grid <- study.area %>%
  st_make_grid(cellsize = grid.size,
               square = FALSE,
               flat_topped = TRUE) %>%
  st_intersection(study.area) %>%
  # st_cast("MULTIPOLYGON") %>%
  st_sf() %>%
  mutate(gridcellid = row_number()) %>%
  st_transform(crs = crs.target)

# # Visualize to check
# tmap::qtm(grid)
# mapview::mapview(grid) # interactive, openstreetmap

# Add centroid lat lon to grid 
centroid.coords <- st_coordinates(st_geometry(st_centroid(grid)))
grid$cell.lon.centroid <- centroid.coords[,1]
grid$cell.lat.centroid <- centroid.coords[,2]

# Export Data
saveRDS(grid, file = paste0(dir.spatial.out, "/", "grid.rds"))
}
# Clear junk
junk_it(args.save, "grid")
```

View the spatial grid if you want...
```{r grid-view, eval=FALSE}
plot(grid["gridcellid"])
```


# Step 3: BBS Data Munging
Depending on the size of the study area, resolution of the grid cells, and whether you've already downloaded the BBS data, this may take a few minutes.
```{r bbs-munge}

# Check for existing files ------------------------------------------------
fns <- list.files(dir.bbs.out)
fns.spatial <- list.files(dir.spatial.out)
if("bbs_spatial.rds" %in% tolower(fns.spatial)) bbs_spatial <- readRDS(paste0(dir.spatial.out, "/", "bbs_spatial.rds"))else{

# Munge BBS data ----------------------------------------------------------
## Import and/or Download BBS Observations and Metadata -----------------------------
#### Original observations data
if("bbs_orig.rds" %in% tolower(fns)){
  bbs_orig <-
    readRDS(paste0(dir.bbs.out, "/bbs_orig.rds"))} else{
      print("grabbing bbs data, this might take 45sec")
      bbs_orig <- grab_bbs_data(sb_dir = dir.bbs.out)
      saveRDS(bbs_orig, paste0(dir.bbs.out, "/bbs_orig.rds"))
}

#### Munged observations data
if (!"bbs_obs.rds" %in% tolower(fns)) {
  bbs_obs <-
    munge_bbs(
      list = bbs_orig,
      spp = interest.species,
      states=states,
      keep.stop.level.data = FALSE
    )
  saveRDS(bbs_obs, paste0(dir.bbs.out, "/bbs_obs.rds"))
} else{
  bbs_obs <- readRDS(paste0(dir.bbs.out, "/bbs_obs.rds"))
}

## Make BBS Spatial Layers ----------------------------------------------
### Create BBS routes spatial layer ----------------------------------------------------------------------
# munges all routes at first then moves to subsetting to the grid, so have patience
# takes about a minute for 1-3 states
cat("Munging the BBS route shapefiles/spatial layer.\nIf `grid` specified, will take a hot minute.\nWILL SOON PASTE ALGEBRA TO MESSAGE OUT ESTIMATED TIME BASED ON STATES AND GRID CELL SIZE")
bbs_spatial <-
  make_bbs_spatial(
    bbs.obs = bbs_obs,
    cws.routes.dir = cws.routes.dir, #location of the CWS BBS routes shapefiles
    usgs.routes.dir = usgs.routes.dir, #location of the USGS BBS routes shapefiles
    crs.target = crs.target,
    routes.keep=unique(bbs_obs$RTENO),
    grid=grid,
    keep.empty.cells =TRUE,
    plot.dir=dir.plots,
    overwrite=TRUE
  )

saveRDS(bbs_spatial, paste0(dir.spatial.out, "/bbs_spatial.rds"))
## View the file with basic bbs stats against the spatial grid
browseURL(list.files(dir.plots, "bbs_spatial_exploratory", full.names = TRUE))
}

junk_it(args.save, "bbs_spatial")
```

# Step 4: eBird Data Munging 
Due to the size of the eBird data, this may take  MANY MANY minutes 
```{r ebird-warnings}
if (parallel::detectCores() <= 4 |
    memory.limit() < 25000)
  warning(
    "You don't have enough RAM and/or CPU to munge the eBird data. Don't blame me if your machine crashes."
  )
cat(
  "Tossing out the garbage (`gc`) and about to deal with this eBird data. Buckle up, buttercup."
)
```


```{r ebird-data}
fns.ebird <- id_ebird_files(dir.ebird.in = dir.ebird.in)
# Filter the eBird Data ---------------------------------------------------
ebird_filtered <- filter_ebird_data(
                                    fns.ebird = fns.ebird,
                                    overwrite = TRUE,
                                    dir.ebird.out = dir.ebird.out,
                                    countries = countries,
                                    states = states,
                                    protocol = c("Traveling","Stationary"),
                                    species = interest.species,
                                    max.num.observers=max.num.observers,
                                    years=year.range
                                    )

## Zero-fill the eBird Data -------------------------------------------------
fns <- list.files(dir.ebird.out, full.names = TRUE, pattern = "filtered.txt")

# would like to get this functional but auk_zerofill currently requires
## VERY specific coltypes and names. not flexible in coltypes...
# ebird_zf <- auk::auk_zerofill(x=fns[fns %>% str_detect("obs")],
#                               sampling_events = fns[fns %>% str_detect("samp")])

ebird_zf <- zerofill_ebird(myList=ebird_filtered, overwrite=FALSE, dir.out=dir.spatial.out)
gc()

## Create the eBird Spatial Layer  -----------------------------------------------------
ebird_spatial <- make_ebird_spatial(df=ebird_zf, crs.target = crs.target)

## Export Data -------------------------------------------------------------
saveRDS(ebird_spatial, file = paste0(dir.spatial.out, "ebird_spatial.rds"))

# remove junk ----------------------------------------------------------------------------
junk_it(args.save, "ebird_spatial")

```
