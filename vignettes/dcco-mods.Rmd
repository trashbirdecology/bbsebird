---
title: "specify and run models"
params:
  dir.proj: "C:/users/jburnett/documents/github/dubcorms/vignettes/DCCO/Double-crested Cormorant_FL-GA_111km_2008-2019"
  sim.data: FALSE
  overwrite.jags.models: FALSE
---

```{r setup}
devtools::install_github('trashbirdecology/dubcorms')
library(dubcorms)
library(tidyverse)
library(jagsUI)
library(coda)
dubcorms::eval_params()
params.temp <- eval_params(params) # we cannot save as params--won't allow us to overwrite
# save params as objects in environment instead of inside a list (b.c of my laziness)
list2env(params.temp, envir = environment())
dir.jags <- paste0(dir.proj, "/jags")
dir.plots <- paste0(dir.proj, "/plots")
dir.models <- paste0(dir.jags, "/models")
dir.exists(dir.jags); dir.exists(dir.plots); dir.exists(dir.models)
```

```{r retrieve-observations}
# Import the data
if(!sim.data)
  jdat <- import_jdat(dir.jags)
if (sim.data)
  jdat  <- sim_data(
    ngrid = 55,
    nroutes = 100,
    nchecklistsmaxperyear = 55, #total MAX num of checklists allowed in study area each year.
    maxgridperroute = 3,
    nyear = 10,
    plot.dir = dir.plots
  )
```

# Step 1: Specify GAMs
Specify the data to use to create basis functions
```{r jagam-data}
# Generate prior distributions for Poisson gam
jagam.data <- 
  data.frame(
    Nib = rep(N = jdat$bbs$Nib[, 1], length(jdat$bbs$lat)),
    x = scale(jdat$bbs$lon),
    y = scale(jdat$bbs$lat)
  )
```

Use \code{mgcv::jagam} to create the base model that should then be further edited for use in JAGS. 
```{r specify-gam-base}
# ind <- names(jdat)
ind <- "bbs"
jagam.mods <- rep(list(NA), length(ind))
names(jagam.mods) <- ind
for(i in seq_along(ind)) {
  mod.name <-  paste0("/jagam_", ind[i])
  mod.fn   <- paste0(dir.models, mod.name, "_unedited.txt")
  #write JAGAM model to file
  jagam.mods[[i]] <-
    mgcv::jagam(
      Nib ~ s(
        x,
        y,
        k = 20,
        ## need to fix to ensure always less than ngrid cells but still high
        bs = 'ds',
        m = c(1, 0.5)
      ),
      sp.prior = "log.uniform",
      data = jagam.data,
      family = "poisson",
      file = mod.fn,
      diagonalize = TRUE
    )
  cat("JAGS model specification saved:\n",
      paste0(dir.models, mod.name, "_unedited.txt"),
      ".\n")
  
} #end gam loop

### gam data for JAGS
jags.data <-
  list(
    ## follows are integers
    nSitesB = dim(jdat$bbs$C)[1],#num routes bbs
    nYearsB = dim(jdat$bbs$C)[2],#num years bbs
    nGridsB = jdat$bbs$ngrid,#num grids in bbs data
    nSitesE = dim(jdat$ebird$C)[1],#num checklists ebird
    nYearsE = dim(jdat$ebird$C)[2],#num years ebird
    nGridsE = jdat$ebird$ngrid,#num grids in ebird data
    nMaxChecklists = jdat$ebird$nMaxChecklistsInGrid,#num routes bbs
    nYearsB = dim(jdat$bbs$C)[2],#num years bbs
    nGridsB = jdat$bbs$ngrid,#num grids in bbs data

    ## follows are matrices with dimensions [route/checklistid (Site) by year]
    Cb = jdat$bbs$C, #counts on BBS 
    Ce = jdat$ebird$C, #counts on eBird
    pc = jdat$bbs$pc,#cars (bbs)
    pn = jdat$bbs$pn,#noise (bbs)
    pw = jdat$bbs$pw,#wind (bbs)
    pf = jdat$bbs$pf,#obs first yr (bbs)
    ## follows are vectors with dimensions == nYears
    nRoutesByYear = , 
    ## follow are vectors with dimensions == nGrid
    area = jdat$bbs$area,#gridcell area 
    hab1 = jdat$bbs$hab1,#made up covar
    hab2 = jdat$bbs$hab2,#made up covar 
    ## follows are matrices with dimensions [site by grid]
    prop = jdat$bbs$prop,#proportion route in cell
    ## follows are data for the GAM
    b = jagam.mods$bbs$jags.data$X#dims nGRidsB by #basis functions/knots
  )
```

# Step 2: Specify HM
## Step 2a: Computational specifications
### MCMC
```{r set-mcmc}
na <- 1000 # number of adaptation iterations
nb <- 5000 # number of iterations for burnin per chain
nc <- 3 # number of chains (min for now) 
ncores <- parallel::detectCores() - 1 # number of cores to use; keep one free just in case, or not
ni <- 20000 # number of iterations per chain
nt <- 10 # thinning rate
```

### Set initial values
```{r set-inits} 
myinits <-list(alpha_pb  = rnorm(1,0,1), 
       alpha_g = rnorm(1, 0, 1), beta_g = rnorm(1, 0, 1),
       beta_pb = rnorm(1,0,1), beta_pw = rnorm(1,0,1), beta_pf = rnorm(1,0,1))
inits <- make_inits_list(myinits, nc)
#gam initial values
# jagam.mods$bbs$jags.ini %>% View()
```

### Parameters monitored
```{r set-params} 
### must not name `params` b/c will conflict with YAML parameters
params.monitor <- c("lambda", "nu",  "Nb", "pBBS")
```

## Step 2b: Specify Model(s)
```{r bbs-pois-base}
mod <- "model{
####################################################
####################################################
# Likelihoods
####################################################
for(t in 1:nYearsB){
  for(s in 1:nSitesB){
    Cb[s,t] ~ dpois(lambda[s])
  } # end bbs data model s
} # end bbs data model t
  
for(s in 1:nSitesB){
  lambda[s]  = inprod(nu[], prop[s,])
} # end s (lambda route)

for(g in 1:nGridsB){
  log(nu[g]) = alpha_g + area[g]*beta_g
} # end g (nu)

####################################################
####################################################
# Priors
####################################################
beta_g    ~ dnorm(0,1)
alpha_g   ~ dnorm(0,1)
####################################################
####################################################
# Derived
####################################################
for(t in 1:nYearsB){
  Nb[t] <- sum(Cb[,t])
}
####################################################
####################################################
}"

## export model
# browseURL(mod.fn)
mod.name <- paste0(dir.models,"/bbs-pois-null") ## not sure why but when i knit the chunks outside this one it doesn't keep the params, so having trouble putting it up there.
mod.fn <- paste0(mod.name, ".txt") # we want to name it now so we can call in jags functions
sink(mod.fn)
cat(mod)
sink()
```

```{r bbs-pois-with-p-covs}
mod <- "model{
####################################################
####################################################
# Likelihoods
####################################################
for(t in 1:nYearsB){
  for(s in 1:nSitesB){
    Cb[s,t] ~ dpois(lambda[s]*pBBS[s,t])
  } # end data model s
} # end data model t

  
for(t in 1:nYearsB){
  for(s in 1:nSitesB){
    logit(pBBS[s,t]) <- alpha_pb + 
                        beta_pf * pf[s,t] + 
                        beta_pw * pw[s,t]
  } # end data model s
} # end data model t


for(s in 1:nSitesB){
  lambda[s]  = inprod(nu[], prop[s,])
} # end s (lambda route)


for(g in 1:nGridsB){
  log(nu[g]) = beta_g*area[g] + alpha_g 
} # end g (nu)

####################################################
####################################################
# Priors
####################################################
## Priors on BBS site(route)-level detection 
alpha_pb   ~ dnorm(0,0.1) # intercept on the BBS detection model
beta_pf   ~ dnorm(0,1) # observer's first year (on BBS or Route)
beta_pw   ~ dnorm(0,1) # wind
## Priors on BBS grid-level covariates
alpha_g    ~ dnorm(0,1) # intercept on the grid covariates model
beta_g    ~ dnorm(0,1) # grid-cell area (scaled)

####################################################
####################################################
# Derived
####################################################
for(t in 1:nYearsB){
  Nb[t] <- sum(Cb[,t])
}
####################################################
####################################################
}"
## export model
# browseURL(mod.fn)
mod.name <- paste0(dir.models,"/bbs-pois-with-p-covs") ## not sure why but when i knit the chunks outside this one it doesn't keep the params, so having trouble putting it up there.
mod.fn <- paste0(mod.name, ".txt") # we want to name it now so we can call in jags functions
sink(mod.fn)
cat(mod)
sink()
```

### BBS + eBird
```{r bbs-ebird}
mod <- "model{
####################################################
### Attempt to incorporate Ce (ebird count processes) in 
####################################################
# Likelihoods
####################################################
for(t in 1:nYearsB){
  for(s in 1:nSitesB){
    Cb[s,t] ~ dpois(lambda[s]*pBBS[s,t])
  } # end data model s
} # end data model t

  
for(t in 1:nYearsB){
  for(s in 1:nSitesB){
    logit(pBBS[s,t]) <- alpha_pb + 
                        beta_pf * pf[s,t] + 
                        beta_pw * pw[s,t]
  } # end data model s
} # end data model t


for(s in 1:nSitesB){
  lambda[s]  = inprod(nu[], prop[s,])
} # end s (lambda route)


for(g in 1:nGridsB){
  log(nu[g]) = beta_g*area[g] + alpha_g 
} # end g (nu)

####################################################
####################################################
# Priors
####################################################
## Priors on BBS site(route)-level detection 
alpha_pb   ~ dnorm(0,0.1) # intercept on the BBS detection model
beta_pf   ~ dnorm(0,1) # observer's first year (on BBS or Route)
beta_pw   ~ dnorm(0,1) # wind
## Priors on BBS grid-level covariates
alpha_g    ~ dnorm(0,1) # intercept on the grid covariates model
beta_g    ~ dnorm(0,1) # grid-cell area (scaled)

####################################################
####################################################
# Derived
####################################################
for(t in 1:nYearsB){
  Nb[t] <- sum(Cb[,t])
}
####################################################
####################################################
}"
## export model
# browseURL(mod.fn)
mod.name <- paste0(dir.models,"/bbs-pois-with-p-covs") ## not sure why but when i knit the chunks outside this one it doesn't keep the params, so having trouble putting it up there.
mod.fn <- paste0(mod.name, ".txt") # we want to name it now so we can call in jags functions
sink(mod.fn)
cat(mod)
sink()
```



# Step 3: Build Model(s)
```{r run-jags}
# models in jags model dir
mod.fns   <- list.files(dir.models, full.names = FALSE, pattern=".txt|.jags") # names of models
mod.names <- sub(".txt|.jags", "", x=mod.fns) # remove the .rds files
mod.fns   <- paste0(dir.models, "/", mod.fns) # tack on the directory to filename after grabbing the mod.names
gam.mod.fns <- mod.fns[str_detect(mod.fns, "jagam")] # remove jags fns
mod.fns <- setdiff(mod.fns, gam.mod.fns) # remove jags fns
# Choose the model to run
for(i in seq_along(mod.fns)) {
  mod.fn   <- mod.fns[i]
  mod.name <- mod.names[i]
  fn.out <- paste0(dir.models, "/", mod.name, ".rds")
  mods.out <- if(i==1){fn.out}else{c(mods.out, fn.out)}
  
  if (file.exists(fn.out) &
      !overwrite.jags.models)
    next(fn.out, " exists. skipping loop", i)
  jags.data$area <- as.vector(scale(jags.data$area, center = TRUE))
  # names(jdat)
  tictoc::tic()
  out <- jagsUI::jags(
    data  = jags.data,
    model.file = mod.fn,
    inits = inits,
    parameters.to.save = params.monitor,
    n.chains = length(inits),
    n.thin = nt,
    n.iter = ni,
    n.burnin = nb
  )
  x = tictoc::toc()
  mod.time <- paste0(round(x$toc - x$tic, 2), " seconds")
  out$tictoc.allchains <- mod.time
  # save model outputs
  saveRDS(out, file = fn.out)
}
## if i keep loop need to add menu for overwriting existing .rds models
```
# Step 4: Check Models
```{r load-mods}
## list of model outputs (as .rds)
mod1 <- readRDS(mods.out[1])
mod2 <- readRDS(mods.out[2])
```


## Convergence
```{r convergence}
coda::densplot(mod2$samples)
fit.mcmc = summary(mod2$samples)       # retrieve results using 'coda' 
lattice::densityplot(fit.mcmc) # plot results using 'coda' 
par(mfrow = c(3, 3))  ;  traceplot(mod2$samples)  ;  par(mfrow = c(1, 1))
```

```{r ppcheck}
```


# Step 5: Inference
```{r}
# view param estimates in separate window
jagsUI::jags.View(mod2, title="simple with pcovs", digits=3)

```
