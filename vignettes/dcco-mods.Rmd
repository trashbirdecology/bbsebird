---
title: "specify and run models"
params:
  dir.proj: "C:/users/jburnett/documents/github/dubcorms/vignettes/DCCO/Double-crested Cormorant_FL-GA_111km_2008-2019"
  sim.data: TRUE
  overwrite.jags.models: FALSE
---

```{r setup}
devtools::install_github('trashbirdecology/dubcorms')
library(dubcorms)
library(tidyverse)
dubcorms::eval_params()
params.temp <- eval_params(params) # we cannot save as params--won't allow us to overwrite
# save params as objects in environment instead of inside a list (b.c of my laziness)
list2env(params.temp, envir = environment())
dir.jags <- paste0(dir.proj, "/jags")
dir.plots <- paste0(dir.proj, "/plots")
dir.models <- paste0(dir.jags, "/models")
dir.exists(dir.jags); dir.exists(dir.plots); dir.exists(dir.models)
```

```{r retrieve-observations}
# Import the data
if(!sim.data)
  jdat <- import_jdat(dir.jags)
if (sim.data)
  bbs  <- sim_bbs(
    ngrid = 55,
    nsite = 100,
    maxgridperroute = 3,
    nyear = 10,
    show.plot = FALSE
  )

if (!exists("jdat"))
  jdat<-list(bbs = bbs
  )
```

# Step 1: Specify GAMs
```{r specify-gams}
ind <- names(jdat)
jagam.mods <- rep(list(NA), length(ind))
names(jagam.mods) <- ind
for(i in seq_along(ind)) {
  mod.name <-  paste0("/jagam_", ind[i])
  mod.fn   <- paste0(dir.models, mod.name, ".txt")
  gamdat <- jdat[[i]]$df.long
  #write JAGAM model to file
  jagam.mods[[i]] <-
    mgcv::jagam(
      C ~ s(
        lon,
        lat,
        k = 20,
        ## need to fix to ensure always less than ngrid cells but still high
        bs = 'ds',
        m = c(1, 0.5)
      ),
      data = gamdat,
      family = "poisson",
      file = mod.fn,
      diagonalize = TRUE
    )
  cat("JAGS model specification saved:\n",
      paste0(dir.models, mod.name, ".txt"),
      ".\n")
  
} #end gam loop

# jagam.mods$bbs$jags.data$X %>% dim()
# jagam.mods$bbs$jags.data$X %>% head()
# jagam.mods$bbs$pregam$model$C %>% str()
# ### This is going to be unnecessarily large for ebird data....it stores all original data, too -- is thi necessary?
# object.size(jagam.mods)
# object.size(jagam.mods$bbs$pregam$model$C)
# object.size(jdat$bbs$C)

# nKnots <- (jagam.mods$bbs$jags.data$X %>% dim())[2]
### gam data for JAGS
jags.data <-
  list(
    ## follows are integers
    nSitesB = dim(jdat$bbs$C)[1],#num routes bbs
    nYearsB = dim(jdat$bbs$C)[2],#num years bbs
    nGridsB = jdat$bbs$ngrid,#num grids in bbs data
    ## follows are matrices with dimensions [site by year]
    Cb = jdat$bbs$C, #counts
    pc = jdat$bbs$pc,#cars
    pn = jdat$bbs$pn,#noise
    pw = jdat$bbs$pw,#wind
    pf = jdat$bbs$pf,#obs first yr
    ## follow are vectors with dimensions == nGrid
    area = jdat$bbs$area,#gridcell area 
    hab1 = jdat$bbs$hab1,#made up covar
    hab2 = jdat$bbs$hab2,#made up covar 
    ## follows are matrices with dimensions [site by grid]
    prop = jdat$bbs$prop,#proportion route in cell
    ## follows are gam data
    bfunB = jagam.mods$bbs$jags.data$X#dims nobs bbs by nKnots
  )

# str(jags.data)
```

# Step 2: Specify HM
## Step 2a: Computational specifications
### MCMC
```{r set-mcmc}
na <- 1000 # number of adaptation iterations
nb <- 5000 # number of iterations for burnin per chain
# nc <- 3 # number of chains (min for now) (defined in call to JAGS as the length of inits list)
ncores <- parallel::detectCores() - 1 # number of cores to use; keep one free just in case, or not
ni <- 10000 # number of iterations per chain
nt <- 10 # thinning rate
```

### Set initial values
```{r set-inits} 
inits <- list(
  list(b1 = rnorm(1,0,1), alpha  = rnorm(1,0,1)),
  list(b1 = rnorm(1,0,1), alpha  = rnorm(1,0,1)),     
  list(b1 = rnorm(1,0,1), alpha  = rnorm(1,0,1))
  )
```

### Parameters monitored
```{r set-params} 
### must not name `params` b/c will conflict with YAML parameters
params.monitor <- c("lambda", "nu",  "N")
```

## Step 2b: Specify Model(s)
```{r bbs-pois-base}
mod <- "model{
####################################################
####################################################
# Likelihoods
####################################################
for(t in 1:nYearsB){
  for(s in 1:nSitesB){
    Cb[s,t] ~ dpois(lambda[s])
  } # end data model s
} # end data model t
  
for(s in 1:nSitesB){
  lambda[s]  = inprod(nu[], prop[s,])
} # end s (lambda route)

for(g in 1:nGridsB){
  log(nu[g]) = area[g]*beta_a + alpha_g 
} # end g (nu)

####################################################
####################################################
# Priors
####################################################
beta_a    ~ dnorm(0,1)
alpha_g ~ dnorm(0,1)
####################################################
####################################################
# Derived
####################################################
for(t in 1:nYearsB){
  N[t] <- sum(Cb[,t])
}
####################################################
####################################################
}"

## export model
# browseURL(mod.fn)
mod.name <- paste0(dir.models,"/bbs-pois-null") ## not sure why but when i knit the chunks outside this one it doesn't keep the params, so having trouble putting it up there.
mod.fn <- paste0(mod.name, ".txt") # we want to name it now so we can call in jags functions
sink(mod.fn)
cat(mod)
sink()
```

```{r bbs-pois-with-p-covs}
mod <- "model{
####################################################
####################################################
# Likelihoods
####################################################
for(t in 1:nYearsB){
  for(s in 1:nSitesB){
    Cb[s,t] ~ dpois(lambda[s]*pBBS[s,t])
  } # end data model s
} # end data model t

  
for(t in 1:nYearsB){
  for(s in 1:nSitesB){
    logit(pBBS[s,t]) <- alpha_pb + 
                        beta_pf * pf[s,t] + 
                        beta_pw * pw[s,t]
  } # end data model s
} # end data model t


for(s in 1:nSitesB){
  lambda[s]  = inprod(nu[], prop[s,])
} # end s (lambda route)


for(g in 1:nGridsB){
  log(nu[g]) = beta_a*area[g] + alpha_g 
} # end g (nu)

####################################################
####################################################
# Priors
####################################################
## Priors on BBS site(route)-level detection 
alpha_pb   ~ dnorm(0,1) # intercept on the BBS detection model
beta_pf   ~ dnorm(0,1) # observer's first year (on BBS or Route)
beta_pw   ~ dnorm(0,1) # wind
## Priors on BBS grid-level covariates
alpha_g    ~ dnorm(0,1) # intercept on the grid covariates model
beta_a    ~ dnorm(0,1) # grid-cell area (scaled)

####################################################
####################################################
# Derived
####################################################
for(t in 1:nYearsB){
  N[t] <- sum(Cb[,t])
}
####################################################
####################################################
}"
## export model
# browseURL(mod.fn)
mod.name <- paste0(dir.models,"/bbs-pois-with-p-covs") ## not sure why but when i knit the chunks outside this one it doesn't keep the params, so having trouble putting it up there.
mod.fn <- paste0(mod.name, ".txt") # we want to name it now so we can call in jags functions
sink(mod.fn)
cat(mod)
sink()
```


# Step 3: Build Model
```{r run-jags}
# models in jags model dir
mod.fns   <- list.files(dir.models, full.names = FALSE, pattern=".txt|.jags") # names of models
mod.names <- sub(".txt|.jags", "", x=mod.fns) # remove the .rds files
mod.fns   <- paste0(dir.models, "/", mod.fns) # tack on the directory  after grabbuing the mod.names
gam.mod.fns <- mod.fns[str_detect(mod.fns, "jagam")] # remove jags fns
mod.fns <- setdiff(mod.fns, gam.mod.fns) # remove jags fns
# Choose the model to run
for(i in seq_along(mod.fns)) {
  mod.fn   <- mod.fns[i]
  mod.name <- mod.names[i]
  fn.out <- paste0(dir.models, "/", mod.name, ".rds")
  mods.out <- if(i==1){fn.out}else{c(mods.out, fn.out)}
  
  if (file.exists(fn.out) &
      !overwrite.jags.models)
    next(fn.out, " exists. skipping loop", i)
  jags.data$area <- as.vector(scale(jags.data$area, center = TRUE))
  # names(jdat)
  tictoc::tic()
  out <- jagsUI::jags(
    data  = jags.data,
    model.file = mod.fn,
    inits = inits,
    parameters.to.save = params.monitor,
    n.chains = length(inits),
    n.thin = nt,
    n.iter = ni,
    n.burnin = nb
  )
  x = tictoc::toc()
  mod.time <- paste0(round(x$toc - x$tic, 2), " seconds")
  out$tictoc.allchains <- mod.time
  # save model outputs
  saveRDS(out, file = fn.out)
}
## if i keep loop need to add menu for overwriting existing .rds models
```
# Step 4: Check Models
## Convergence
```{r convergence}
## list of model outputs (as .rds)
mod1 <- readRDS(mods.out[1])
mod2 <- readRDS(mods.out[2])

```



