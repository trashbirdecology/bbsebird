---
title: "JAGS Models"
output:
  pdf_document: default
params:
  dir.proj: "C:/Users/jburnett/OneDrive - DOI/research/cormorants/dubcorm-data-backup/"
  mod.name: "bbs-grid-level-pois.txt"
  fn.dataint: "2_Data_integration.Rmd"
  fn.munging: "1_Data-munging.Rmd"
---
Use this script to create data for use in JAGS modelling activities. 

# Step 1: Setup 
 This chunk sources some redundant chunks in the data-munging r markdown
```{r setup}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  message = TRUE, 
  echo=FALSE, 
  warning=FALSE, 
  fig.path="/plots/", 
  tidy=TRUE, 
  include=FALSE
)
# rm(list=ls())# for dev
if(is.null(params$fn.munging)) stop("RMD parameter `params$fn.munging` MUST be specified in YAML header.")
chunk_labels <- c("libraries", 
                 "specs-dirs",
                 "specify-junk"
                 )
library(dubcorms)
```

Source directories and such from data munging RMD
```{r source-chunks, include=FALSE}
### for somet reason i cant get this to work by using dubcorms::source_rmd_chunks(). it works when i enter the function but not interactively... stupiddkghsgkjzh ;gkjghk d;j gh
temp <- tempfile(fileext=".R")
knitr::purl(params$fn.munging, output = temp)

text <- readr::read_file(temp)
text <- purrr::map(chunk_labels, ~stringr::str_extract(text, glue::glue("(## ----{var})(.|[:space:])*?(?=(## ----)|$)", var = .x))) %>%
    stringr::str_c(collapse = "\n")
readr::write_file(text, temp)
source(temp)
rm(temp, text)
```

# Step 1: Handle Observations Data
## Import data
If data already exists, we can just import it from file. Otherwise, you will need to run through "1-Data_Munging.Rmd", which will take a hot minute.
```{r import-jdat, echo=TRUE}
fn <- list.files(dir.jags, full.names = TRUE, "jdat.rds")
if(length(fn)>1) "more than one filename in object `fn`. check filenames in dir.jags"
jdat <- readRDS(fn)
cat("jdat is of class ", toupper(class(jdat)) , " and contains the following ", length(jdat), " lists:")
names(jdat)
```

## Explore available data
If desired, go ahead and explore the data. 
```{r data-metadata-explore, eval=FALSE}
### placeholder for creating some tables describing the data. 
jdat$bbs$C.route %>% head(2)
jdat$bbs$C %>% head(2)
jdat$grid$area # area (m^2) of the grid cell within confines of study area
jdat$grid$period # years of study
jdat$grid$T # number of years
```

Get the dimensions of the BBS data objects in jdat
```{r data-structure-bbs}
### will turn this into a function probably so we can grab dims of all our data.
for(i in seq_along(jdat$bbs)){
  if(i == 1 ){
    bbs.structure = data.frame(matrix(nrow=max(seq_along(jdat$bbs)), ncol=5)) 
    colnames(bbs.structure) = c("class", "length", "nrow", "ncol", "nslice") 
              }
  dat   <-  jdat$bbs[[i]]
  class <-  class(dat)[1] # for multiple classifications will just take the first
  nrow   = dim(dat)[1] #num cols
  ncol   = dim(dat)[2] #num rows
  nslice = dim(dat)[3] #num slices
  # if all those are NA, then its a single value.
  if(all(is.na(c(nrow, ncol, nslice)))){length=length(dat)}else{length=NA}
  if(is.null(nrow))nrow=NA    
  if(is.null(ncol))ncol=NA    
  if(is.null(nslice))nslice=NA    
  
  
  bbs.structure[i,1] <- class
  bbs.structure[i,2] <- length
  bbs.structure[i,3] <- nrow
  bbs.structure[i,4] <- ncol
  bbs.structure[i,5] <- nslice
  rownames(bbs.structure)[i] <-  names(jdat$bbs)[i] 
}

# for reference
View(bbs.structure)
kableExtra::kable(bbs.structure) %>%
  kableExtra::kable_minimal()
```


# Step 2: Write JAGS Models
From here, you can specify JAGS models inside R by interactively creating text files, or you can point to the file in the JAGS model. 

## BBS-only Poisson
Grab only necessary data
```{r grab-data-bbs}
w.prop <- tidyr::replace_na(jdat$bbs$w.prop, 0)
y      <- jdat$bbs$C.route
G      <- jdat$grid$G
G.bbs  <- jdat$bbs$
T      <- jdat$grid$T
R      <- jdat$bbs$R
area   <- scale(tidyr::replace_na(units::drop_units(jdat$grid$area), 0), 
                center = FALSE) # not sure why class is array/matrix, need to fix in munging process.
grid.cov1   <- sample(area/10) #dummy
```

## Make Named Data List for JAGS
```{r make-jags-list}
names.jags <- c(
  "w.prop", 
  "y", 
  "G", 
  # "G.bbs", 
  "T", 
  "R", 
  "area", 
  "grid.cov1"
)
if(any(lapply(names.jags, function(x) is.null(eval(parse(text=paste(x)))))))"at least one element is NULL or empty in `names.jags`"

jags.data <- list()
for(i in seq_along(names.jags)){
  jags.data[[i]] <- eval(parse(text=paste(names.jags[i])))
  # doing this inside loop to prevent issues where data DNE
  names(jags.data)[[i]] <- names.jags[i] 
}
names(jags.data) <- names.jags
```



Specify JAGS model and etc.
```{r write-model}
# y[r,t] = observed count on route r at time t 
# lambda.grid[g,t] = expected count in a grid cell, g at time t
# lambda.route[r,t] = expected count on a route r at time t
# w.prop[r,g] = % of route r in grid cell g
# area[g] = m^2 of grid cell g 

mod <- "
model{
# Likelihood

### will speed things up later by splitting up the for loops to avoid redundant calcs
for(r in 1:R){
  for(t in 1:T){  

      y[r,t] ~ dpois(lambda.route[r,t])
      
    for(g in 1:G){

        lambda.route[r,t] <- sum(w.prop[r,g] * lambda.grid[g,t])
  
        log(lambda.grid[g,t]) <-  log(area[g]) + beta0[g] + beta1*grid.cov1[g]
      
    } # end G
    
  } # end T
  
} # end R


# Priors
  beta0 ~ dunif(0,100)
  beta1 ~ dunif(0,100)

# Derived Parameters
# N <- sum(y)
  
}"
## export model
mod.fn <- paste0(dir.models, params$mod.name) # we want to name it now so we can call in jags functions
write.table(mod, file=mod.fn)
```



# Step 3: Computational Specifications
## MCMC
```{r set-mcmc}
na <- 1000 # number of adaptation iterations
nb <- 5000 # number of iterations for burnin per chain
nc <- 3 # number of chains (min for now)
ncores <- parallel::detectCores() - 1 # number of cores to use; keep one free just in case, or not
ni <- 10000 # number of iterations per chain
nt <- 10 # thinning rate
```

## Initial values
```{r set-inits} 
inits <- function() list(beta0 = rnorm(1,0,10), beta1 = rnorm(1,0,10) ) 
```

## Parameters monitored
```{r set-params} 
### must not name `params` b/c will conflict with YAML parameters
params.monitor <- c("lambda.grid", "lambda.route", "beta0", "beta1", "N")
```


# Step 4: Computation (Run Model(s))
```{r}
out <- jagsUI::jags(data  = jags.data, 
                    model.file = mod.fn,
                    inits = inits, 
                    parameters.to.save = params.jags, 
                    n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb) 
```

