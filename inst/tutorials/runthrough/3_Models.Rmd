---
title: "JAGS Models"
output:
  pdf_document: default
params:
  mod.name: "bbs-grid-level-pois.txt"
  fn.setup: "0_setup.rmd"
---
Use this script to create data for use in JAGS modelling activities. 

See page [45 of the JAGS manual](https://people.stat.sc.edu/hansont/stat740/jags_user_manual.pdf) for     helpful functions. 

# Step 1: Setup 
 This chunk sources some redundant chunks in the data-munging r markdown
# Step 1: Setup 
 This chunk sources some redundant chunks in the data-munging r markdown
```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  message = TRUE, 
  echo=FALSE, 
  warning=FALSE, 
  tidy=TRUE, 
  include=FALSE
)
setup.chunk.needed<-FALSE
temp=tempfile(fileext=".R")
knitr::purl(params$fn.setup, output=temp)
source(temp)
```

# Step 1: Handle Observations Data
## Import data
If data already exists, we can just import it from file. Otherwise, you will need to run through "1-Data_Munging.Rmd", which will take a hot minute.
```{r import-jdat, echo=TRUE}
fn <- list.files(dir.jags, full.names = TRUE, "jdat.rds")
if(length(fn)>1) "more than one filename in object `fn`. check filenames in dir.jags"

jdat <- readRDS(fn)
cat("jdat is of class ", toupper(class(jdat)) , " and contains the following ", length(jdat), " lists:")
names(jdat)
```

## Explore available data
If desired, go ahead and explore the data. 
```{r data-metadata-explore, eval=FALSE}
### placeholder for creating some tables describing the data. 
jdat$bbs$C.route %>% head(2)
jdat$bbs$C %>% head(2)
jdat$grid$area # area (m^2) of the grid cell within confines of study area
jdat$grid$period # years of study
jdat$grid$T # number of years

```

Get the dimensions of the BBS data objects in jdat
```{r data-structure-bbs}
### will turn this into a function probably so we can grab dims of all our data.
for(i in seq_along(jdat$bbs)){
  if(i == 1 ){
    bbs.structure = data.frame(matrix(nrow=max(seq_along(jdat$bbs)), ncol=5)) 
    colnames(bbs.structure) = c("class", "length", "nrow", "ncol", "nslice") 
              }
  dat   <-  jdat$bbs[[i]]
  class <-  class(dat)[1] # for multiple classifications will just take the first
  nrow   = dim(dat)[1] #num cols
  ncol   = dim(dat)[2] #num rows
  nslice = dim(dat)[3] #num slices
  # if all those are NA, then its a single value.
  if(all(is.na(c(nrow, ncol, nslice)))){length=length(dat)}else{length=NA}
  if(is.null(nrow))nrow=NA    
  if(is.null(ncol))ncol=NA    
  if(is.null(nslice))nslice=NA    
  
  
  bbs.structure[i,1] <- class
  bbs.structure[i,2] <- length
  bbs.structure[i,3] <- nrow
  bbs.structure[i,4] <- ncol
  bbs.structure[i,5] <- nslice
  rownames(bbs.structure)[i] <-  names(jdat$bbs)[i] 
}

# for reference
View(bbs.structure)
# kableExtra::kable(bbs.structure) %>%
#   kableExtra::kable_minimal()
```


# Step 3: Computational Specifications
## MCMC
```{r set-mcmc}
na <- 1000 # number of adaptation iterations
nb <- 5000 # number of iterations for burnin per chain
# nc <- 3 # number of chains (min for now) (defined in call to JAGS as the length of inits list)
ncores <- parallel::detectCores() - 1 # number of cores to use; keep one free just in case, or not
ni <- 10000 # number of iterations per chain
nt <- 10 # thinning rate
```

## Initial values
```{r set-inits} 
inits <- list(
  list(alpha = rnorm(1,0,10), beta1 = rnorm(1,0,10)),
  list(alpha = rnorm(1,0,10), beta1 = rnorm(1,0,10)),     
  list(alpha = rnorm(1,0,10), beta1 = rnorm(1,0,10))
  ) 
```

## Parameters monitored
```{r set-params} 
### must not name `params` b/c will conflict with YAML parameters
params.monitor <- c("lambda.route", "lambda.grid", "alpha", "beta1", "N")
```

# Step 2: Write JAGS Models
From here, you can specify JAGS models inside R by interactively creating text files, or you can point to the file in the JAGS model. 

## BBS-only Poisson
Grab only necessary data
```{r grab-data}
w.prop <- tidyr::replace_na(jdat$bbs$w.prop, 0)
y      <- jdat$bbs$C.route
G      <- jdat$grid$G
G.bbs  <- jdat$bbs$G.bbs
T      <- jdat$grid$T 
if(is.null(T)|length(T)!=1) stop("issues defining `T` in chunk grab-data. must fix.")
R      <- jdat$bbs$R
area   <- scale(tidyr::replace_na(units::drop_units(jdat$grid$area), 0), 
                center = FALSE) %>% as.vector() # not sure why class is array/matrix, need to fix in munging process.
grid.cov1   <- sample(area/10) #dummy

## expected counts at the grid cell level per year (dim: g,t)
#### aperm flips the dimensions around first then compute colsums to get total C at a g and t
C.grid.sums <- t(colSums(aperm(jdat$bbs$C.grid, c(1,2,3)), na.rm=TRUE))## probbaly shorter way of doing this with aperm and no transpose.
# dim(C.grid.sums)

```

## Make Named Data List for JAGS
```{r make-jags-list}
names.jags <- c(
  "w.prop", 
  "y", 
  "C.grid.sums", # sum of counts in a single grid cell at time t
  "C.grid.weighted", # weighted count at the route and grid level per year 
  "C.grid.weighted.sum", # total weighted count at the grid-level per year
  "G", 
  # "G.bbs", 
  "T", 
  "R", 
  "area", 
  "grid.cov1"
)
if(any(lapply(names.jags, function(x) is.null(eval(parse(text=paste(x)))))))"at least one element is NULL or empty in `names.jags`"

jags.data <- list()
for(i in seq_along(names.jags)){
  jags.data[[i]] <- eval(parse(text=paste(names.jags[i])))
  # doing this inside loop to prevent issues where data DNE
  names(jags.data)[[i]] <- names.jags[i] 
}
names(jags.data) <- names.jags
```

## Write JAGS model to file
```{r write-model}
mod <- "model{
for(r in 1:R){
  for(t in 1:T){  
      y[r,t] ~ dpois(lambda[r,])
    for(g in 1:G){ 
      lambda <- inprod(w.prop, nu) # lambda should have dimensions[r,]
      log(nu[g]) <- area[g] + alpha[g] + beta1[g]*grid.cov1[g]
      } # end g
    } # end T
  } # end r 

# Priors
for(g in 1:G){
  alpha[g] ~ dunif(0,10)
  beta1[g] ~ dunif(0,10)
}
# Derived Parameters
for(t in 1:T){
 N[t] <- sum(y[,t])
}
}"
## export model
mod.fn <- paste0(dir.models, params$mod.name) # we want to name it now so we can call in jags functions
sink(mod.fn)
cat(mod)
sink()
```


# Step 4: Make Chains
```{r make-jm}
# setup mcmc chain
# browseURL(mod.fn) ### open model file if you please
jm <- rjags::jags.model(file = mod.fn,
                        data = jags.data, 
                        inits = inits,
                        n.chains = length(inits), 
                        n.adapt = na)

zm <- coda.samples(jm, 
                  variable.names = params.monitor,
                  n.iter = ni, 
                  n.thin = nt)

# out <- jagsUI::jags(data  = jags.data,
#                     model.file = mod.fn,
#                     inits = inits,
#                     parameters.to.save = params.monitor,
#                     n.chains = length(inits), n.thin = nt, n.iter = ni, n.burnin = nb)
```

