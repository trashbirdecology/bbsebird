---
title: "Munge eBird and BBS Data for Integrated Model"
params:
  fn.setup: "0_setup.rmd"
  get.sunlight: FALSE # if you want sun/moon rise/set times set to TRUE
---
```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  message = TRUE, 
  echo=FALSE, 
  warning=FALSE, 
  tidy=TRUE, 
  include=FALSE
)

## establish conditions 
 eval_sunlight <- params$get.sunlight 
 

temp=tempfile(fileext=".r")
knitr::purl(params$fn.setup, output=temp)
source(temp)
```



# Step 1: Make a Spatial Grid
If the spatial grid R object, `grid.rds`, already exists in `r dir.proj.out`, load it into file. If not, will create a new spatial grid and save to file. 
```{r make-grid}
## If a grid.rds is saved in project directory, will not run script and instead will load that file into memory
## load in that rds.
if("grid.rds" %in% list.files(dir.spatial.out)) grid <- readRDS(paste0(dir.spatial.out, "/", "grid.rds"))else{
study.area <-
  rnaturalearth::ne_states(country = countries, returnclass = "sf") %>%
  # remove region(s)
  filter(tolower(name) %in% tolower(states)) %>%
  filter(!tolower(name) %in% tolower(region.remove)) %>%
  sf::st_transform(study.area, crs = crs.target)
# unique(study.area$adm0_a3) #should add a test here to make sure number of countries expected is grabbed.

# throw a grid over the study area layer
grid <- study.area %>%
  sf::st_make_grid(cellsize = grid.size,
               square = FALSE,
               flat_topped = TRUE) %>%
  sf::st_intersection(study.area) %>%
  # st_cast("MULTIPOLYGON") %>%
  sf::st_sf() %>%
  mutate(gridcellid = row_number()) %>%
  sf::st_transform(crs = crs.target)

# add the grid cell area as a variable
grid$area <- sf::st_area(grid)

# # Visualize to check
# tmap::qtm(grid)
# mapview::mapview(grid) # interactive, openstreetmap

# Add centroid lat lon to grid 
centroid.coords <- sf::st_coordinates(sf::st_geometry(sf::st_centroid(grid)))
grid$cell.lon.centroid <- centroid.coords[,1]
grid$cell.lat.centroid <- centroid.coords[,2]
grid$area <- st_area(grid)

# Export Data
saveRDS(grid, file = paste0(dir.spatial.out, "/", "grid.rds"))
}
# Clear junk
args.save <- junk_it(args.save, "grid")
```

# Step 2: Load or Create BBS and eBird Data
## Step 2a: Check to see if the munged spatial data files already exist.
If these files already exist, this will load in those files and skip steps 3b and 3c.
```{r spatial-files-load, include=FALSE}
## If all files do not exist, then something is may have gone awry in a previous session and we should be safe and re-create everything.
fns.spatial <- c("bbs_spatial.rds", "ebird_spatial.rds", "grid.rds")
if(all(fns.spatial %in% list.files(dir.spatial.out))){
  cat("importing bbs, ebird and grid sf objects.\n\n")
  fns.spatial   <- list.files(dir.spatial.out, full.names = TRUE)
  bbs_spatial   <- readRDS(fns.spatial[stringr::str_detect(fns.spatial, "bbs_spat")])
  grid          <- readRDS(fns.spatial[stringr::str_detect(fns.spatial, "grid")])
  ebird_spatial <- readRDS(fns.spatial[stringr::str_detect(fns.spatial, "ebird_spat")]) # sometimes this fails because ebird data hates me, so re-run plz
  ## If you want to check out the spatial grid wtih some basic BBS stats, go for it:
# if(params$browse.plots) 
  browseURL(list.files(dir.plots, "bbs_spatial_exploratory.pdf", full.names=TRUE))# opens the PDF!
  }
```

## Step 2b: BBS Data Munging
Depending on the size of the study area, resolution of the grid cells, and whether you've already downloaded the BBS data, this may take a few minutes.
```{r bbs-munge}
# Do not run if bbs_spatial already exists
if(!exists("bbs_spatial")){
# Check for existing files ------------------------------------------------
fns <- list.files(dir.bbs.out)
fns.spatial <- list.files(dir.spatial.out)
if("bbs_spatial.rds" %in% tolower(fns.spatial)) bbs_spatial <- readRDS(paste0(dir.spatial.out, "/", "bbs_spatial.rds"))else{

# Munge BBS data ----------------------------------------------------------
## Import and/or Download BBS Observations and Metadata -----------------------------
#### Original observations data
if("bbs_orig.rds" %in% tolower(fns)){
  bbs_orig <-
    readRDS(paste0(dir.bbs.out, "/bbs_orig.rds"))
  } else{
      print("downloading the bbs data, this might take 45sec")
      bbs_orig <- grab_bbs_data(sb_dir = dir.bbs.out)
      saveRDS(bbs_orig, paste0(dir.bbs.out, "/bbs_orig.rds"))
}

#### Munged observations data
if (!"bbs_obs.rds" %in% tolower(fns)) {
  bbs_obs <-
    munge_bbs(
      list = bbs_orig,
      spp = params$species,
      states=states,
      keep.stop.level.data = FALSE
    )
  saveRDS(bbs_obs, paste0(dir.bbs.out, "/bbs_obs.rds"))
} else{
  bbs_obs <- readRDS(paste0(dir.bbs.out, "/bbs_obs.rds"))
}
## Make BBS Spatial Layer ----------------------------------------------
# munges all routes at first then moves to subsetting to the grid, so have patience
# takes about a minute for 1-3 states
cat("Munging the BBS route shapefiles/spatial layer.\nIf `grid` specified, will take a hot minute.\n\n")
bbs_spatial <-
  make_bbs_spatial(
    bbs.obs = bbs_obs,
    cws.routes.dir = cws.routes.dir, #location of the CWS BBS routes shapefiles
    usgs.routes.dir = usgs.routes.dir, #location of the USGS BBS routes shapefiles
    crs.target = crs.target,
    routes.keep=unique(bbs_obs$RTENO), 
    grid=grid,
    keep.empty.cells =TRUE,
    plot.dir=dir.plots,
    overwrite=TRUE
  )

saveRDS(bbs_spatial, paste0(dir.spatial.out, "/bbs_spatial.rds"))
## View the file with basic bbs stats against the spatial grid
# browseURL(list.files(dir.plots, "bbs_spatial_exploratory", full.names = TRUE))
}

args.save <- junk_it(args.save, "bbs_spatial")
}
```

## Step 2c: eBird Data Munging 
Due to the size of the eBird data, it may take many many minutes to munge the data. 
```{r ebird-data}
# Do not run if bbs_spatial already exists
if(!exists("ebird_spatial")){
if (parallel::detectCores() <= 4 |
    memory.limit() < 25000)
  warning(
    "You probably don't have enough RAM and/or CPU to munge the eBird data. Don't blame me if your machine crashes. If `filter_ebird_data` takes longer than 20 minutes and your spatial extent <~5 u.s. states, something is probably wrong.\n\n"
  )

fns.ebird <- id_ebird_files(dir.ebird.in = dir.ebird.in)

# Filter the eBird Data ---------------------------------------------------
ebird_filtered <- filter_ebird_data(
                                    fns.ebird = fns.ebird,
                                    overwrite = FALSE,
                                    dir.ebird.out = dir.ebird.out,
                                    countries = countries,
                                    states = states,
                                    protocol = c("Traveling","Stationary"),
                                    species = params$species,
                                    max.num.observers=max.num.observers,
                                    years=year.range
                                    )

## Zero-fill the eBird Data -------------------------------------------------
# fns <- list.files(dir.ebird.out, full.names = TRUE, pattern = "filtered.txt")

# would like to get this functional but auk_zerofill currently requires
## VERY specific coltypes and names. not flexible in coltypes...
# ebird_zf <- auk::auk_zerofill(x=fns[fns %>% stringr::str_detect("obs")],
#                               sampling_events = fns[fns %>% stringr::str_detect("samp")])
ebird_zf <- zerofill_ebird(myList=ebird_filtered, overwrite=FALSE, dir.out=dir.ebird.out)

## Create the eBird Spatial Layer  -----------------------------------------------------
### need to add argument in make_ebird_spatial function to load in file if it exists...
### maybe also save to file inside that funciton 
ebird_spatial <- make_ebird_spatial(df=ebird_zf, crs.target = crs.target, grid = grid)

## Export eBird Spatial Data -------------------------------------------------------------
saveRDS(ebird_spatial, file = paste0(dir.spatial.out, "ebird_spatial.rds"))
# list.files(dir.spatial.out, "spatial.rds")
# remove junk ----------------------------------------------------------------------------
args.save <- junk_it(args.save, "ebird_spatial")
}
```

## Step 2d: Basic Tests
Just double-check the CRS on the spatial files. They all should be the same before we integrate. 
```{r test-crs}
if(!(sf::st_crs(grid)==sf::st_crs(bbs_spatial) & sf::st_crs(ebird_spatial)==sf::st_crs(grid)))stop("Warning. The ebird, bbs, and grid spatial layers are not in same projection and/or CRS.")

if(!all(grid$gridcellid %in% unique(c(ebird_spatial$gridcellid, bbs_spatial$gridcellid))))
  warning("Empty grid cells (no ebird or bbs data) are not represented in the bird data.\nShould make sure empty cells are added to bird data.")
```

# Step 3: Align eBird and BBS Data Further
To ensure proper integration (or rather, use of all data in JAGS) we need to munge the ebird and bbs spatial data just a little bit. We first ensure column names map to each other, where appropriate (e.g., bird count, dates).
```{r match-colnames}
## Force BBS colnames to lowercase.
names(bbs_spatial) <- tolower(names(bbs_spatial))
bbs_spatial   <- match_col_names(bbs_spatial)
ebird_spatial <- match_col_names(ebird_spatial)
```

Next, munge the dates, times, julian dates, and days of year for each dataset such that we can properly align on the temporal dimension.
```{r munge-dates-times}
cat("managing dates and times of spatial objects")
# Dates ---------------------------------------------
### make julian dates
bbs_spatial$date <- lubridate::as_date(bbs_spatial$date)
ebird_spatial$date <- lubridate::as_date(ebird_spatial$date)
## base date for julian date
#### eventually will need to save this or export it somewhere, maybe add it to jags list idk
base.date <- min(c(bbs_spatial$date, ebird_spatial$date), na.rm=TRUE)
## make julian dates
bbs_spatial$julian <- julian(bbs_spatial$date, origin = base.date)
ebird_spatial$julian <- julian(as.Date(ebird_spatial$date), origin = base.date)
## make day of year
ebird_spatial$yday <- lubridate::yday(ebird_spatial$date)
bbs_spatial$yday <- lubridate::yday(bbs_spatial$date)

## Filter days of the year if specified
if(exists("yday")) ebird_spatial <- ebird_spatial %>%
  filter(yday >= min.yday & yday <= max.yday)
if(exists("yday")) ebird_spatial <- ebird_spatial %>%
  filter(yday >= min.yday & yday <= max.yday)

# Times ---------------------------------------------
### this is an ugly workaround and can be improved, including throwing the processes into
### the BBS and eBird munging functions but this is it for now.
bbs_spatial$starttime=hms::as_hms(as.POSIXct(bbs_spatial$starttime, format="%H%M"))
bbs_spatial$endtime=hms::as_hms(as.POSIXct(bbs_spatial$endtime, format="%H%M"))
ebird_spatial$time_observations_started=hms::as_hms(as.POSIXct(ebird_spatial$time_observations_started, format="%H:%M:%S"))
```

If you don't need local sunlight/rise/set times, specify `eval=FALSE` in this chunk. This process takes a while and sometimes crashes when computing on the ebird data. 
```{r munge-sunlight, eval=eval_sunlight}
## eventually--need to move this into the munging phases so we dont have to continue to recalculate it...
# Sunlight/daylight/moonlight ---------------------------------------------
## here, data must have columns lat and lon. I took care of this in
## utils.R function `match_col_names()`
cat("calculating astronomical stats...yes, the astronomy definition.\n")
sunlight.keep <- c("dawn", "solarNoon", "sunrise","sunriseEnd")

bbs.sunlight <- suncalc::getSunlightTimes(data=bbs_spatial %>% distinct(date, lon, lat),
                                            keep = sunlight.keep)

## ebird is so large that I need to split up b/c calculating astronomical info takes forever.
## i'd like to use kit::funique, but cannot figure out how to do that with >1 columns.
### so, am resorting to this method.
x <- ebird_spatial %>% dplyr::select(date, lat, lon)
chunks <- parallel::splitIndices(nrow(x), 100)
for(i in seq_along(chunks)){
  if(i==1) ebird.sunlight <- NULL
  rows = as.data.frame(chunks[i])
  chunk.start = min(rows[1])
  chunk.end   = max(rows[1])
  dat = x[chunk.start:chunk.end, ]
  dat = suncalc::getSunlightTimes(data=dat,
                            keep = sunlight.keep)

  ebird.sunlight <- dplyr::bind_rows(ebird.sunlight,dat)
  rm(dat, chunk.end, chunk.start, rows)
}

### turn vars in sunlight.keep into time only (otherwise they are in YYYY-MM-DD HH-MM-SS; we need only HH-MM)
ebird.sunlight <- ebird.sunlight  %>%
  dplyr::mutate(across(sunlight.keep, hms::as_hms))
bbs.sunlight <- bbs.sunlight %>%
  dplyr::mutate(across(sunlight.keep, hms::as_hms))

# ### dates are a pain in my ass...fix them before attempting a join. will need to address this above somehwere...this is ridiculous ---need to just ensure this is working as expected before deleting unused code:
# str(bbs_spatial$date); str(bbs.sunlight$date)
# str(ebird_spatial$date); str(ebird.sunlight$date)

### add sunlight information to spatial data sets
bbs <- left_join(bbs_spatial, bbs.sunlight)
ebird <- left_join(ebird_spatial, ebird.sunlight)
```
```{r rename-spatial-obj}
# if we didn't calculate sunlight then just rename bbs_spatial as new object to output
##note: if they are identical it will not make a copy just assign it to the same object. 
if(!exists("bbs")) bbs   <- bbs_spatial
if(!exists("ebird")) ebird <- ebird_spatial
```


Export all these spatially-referenced data to a folder for quick use in JAGS data munging activities.
```{r export-munged-data}
saveRDS(bbs, file=paste0(dir.jags, "bbs.rds"))
saveRDS(grid, file=paste0(dir.jags, "grid.rds"))
saveRDS(ebird, file=paste0(dir.jags, "ebird.rds"))
args.save <- junk_it(args.save, c("bbs","grid","ebird"))
```

