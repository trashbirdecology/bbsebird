---
title: "Munge eBird and BBS Data for Integrated Model"
params: 
  dir.proj: "C:/Users/jburnett/OneDrive - DOI/research/cormorants/dubcorm-data-backup/"
  plot:     TRUE 
  devmode:  TRUE 
  browse.plots: false
---

```{r setup, include = FALSE}
# if not in development mode (i.e. ur not jessica) this menu will ensure you're in the right working directory!
if(!params$devmode) if(menu(title = cat("Your current working directory is: \n", getwd(), "\n Is this correct?"), 
     choices = c("Yes", "No")) == 2)stop("Please change your working directory to desired location before proceeding.\n\n")

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  message = TRUE, 
  echo=FALSE, 
  warning=FALSE
)

```

```{r libraries, echo=TRUE}
## Users may run into issues when installing the following packages:
devtools::install_github("ropensci/rnaturalearth", force=FALSE) ## must install from GH -- source has unresolved issues for 2+years (see issue https://github.com/ropensci/rnaturalearthhires/issues/1)
unloadNamespace("dubcorms") # just a precaution to ensure we get most recent dev version of pkg
devtools::install_github("trashbirdecology/dubcorms", force=FALSE)


library(dubcorms)
library(bbsAssistant)
library(ggplot2)
library(reshape2)
library(dplyr) # we use a LOT of functions from here and often so just load the entire thing
library(sf) # we use a LOT of functions from here and often so just load the entire thing
```
# Step 1: Setup and Specifications
## Specs for data subsetting
First, specify the species, regions, and time frames where necessary. Future development suggests include adding everything in the chunk below into the YAML as params. 
```{r specs-subsetting, echo=TRUE}
## List out the various uses of the species names and abbreviations, just to be safe. 
interest.species <- c("DOCCOR", "DOCCO", "DCCO", "DCCOR", "Double-crested Cormorant", "Double Crested Cormorant") 

## List the countries of interest
countries <- c("Canada","USA", "United States", "United States of America") # used to create base maps

## Specify the regions you know you definitely don't want to use.
region.remove = c("Alaska", "Hawaii", "Northwest Territories", "Yukon", "Nunavut", "Yukon Territory") 

## Specify the states/provinces of interest.
states <- c("FL", "US-FL", "Florida")

## Time frames
### range of years for subsetting observations
year.range <- c(2008:2019) # no bbs data for 2020
# year.range <- c(2008:lubridate::year(Sys.Date()))
### range of days of the year for subsetting eBird and BBS data 
min.yday <- 91  # approximate breeding season day start (day of year)
max.yday <- 245 # approximate breeding season day end   (day of year)
```

## BBS Data Specifications
The following specifications are for munging BBS data
```{r specs-bbs, echo=FALSE}
include.unid <- FALSE ## Whether or not to include UNIDENTIFIED // hybrid species
```

## eBird Data Specifications
The following specifications are for munging eBird data
```{r specs-ebird}
ebird.protocol <- c("Traveling", "Stationary")
complete.checklists.only <- TRUE
max.effort.mins <-  3*60 ## arbitrary
max.effort.km   <-  5 #This is coarse also, typically 5km or less
max.num.observers <- 10
mmyyyy <- "Oct-2021" # month and year of most recent ebird EBD/samp download in file.
```


## Geospatial specifications
```{r specs-geospatial}
## specify the target geographic or projected coordinate reference system (CRS)
crs.target <- 4326 # 4326 == unprojected; 5070=Alberts equal area (used by USGS)

## provide the desired grid cell size (units== decimal degrees)
### A good estimate for large-scale (>=state) studies in North Am.
#### is that there are 111.111km in 1 degree latitude or longitude
#### miles to km: km=1.61*miles
grid.size=1.00 #== 1 dec deg
```

## Directory specifications and naming
```{r specs-dirs}
## Where is your original eBird data stored?
dir.ebird.in <- paste0(params$dir.proj, "ebird")
## Where are the BBS route shapefiles stored?
cws.routes.dir <- paste0(params$dir.proj, "/bbs/route_shapefiles/cws")
usgs.routes.dir <- paste0(params$dir.proj, "/bbs/route_shapefiles/usgs")

if(!any(length(list.files(cws.routes.dir))>0)) stop("No files exist `cws.routes.dir` or `usgs.routes.dir`. Please check directory specification.\n")

if(!length(list.files(dir.ebird.in)>0)) stop("No files exist in `dir.ebird.in`. Please check directory specification.\n")

## automatically creates a new directory for storing munged data, results, figures, etc. based on project shorthand name. 
# dir.proj.out <- paste0(proj.shorthand,"-example-", round(grid.size*111.111), "km/")
dir.proj.out <- paste0(getwd(),"/")
## where to store the JAGS objects
dir.jags <- paste0(dir.proj.out, "jags/")
dir.bbs.out <- paste0(dir.proj.out,"bbs/")
dir.ebird.out <- paste0(dir.proj.out,"ebird/")
dir.spatial.out <- paste0(dir.proj.out,"spatial/")
dir.plots <- paste0(dir.proj.out, "plots/")
sapply(c(dir.proj.out, dir.bbs.out, dir.ebird.out, dir.spatial.out, dir.jags, dir.plots), FUN=function(x) dir.create(x, showWarnings = FALSE))
```

<!-- ## Set Chunk Evaluation Conditions -->
```{r set-default-eval-conditions}
# will do this later.
# if(!exists("params")) params <- list()
# 
# names   <- c("overwrite.jdat", 
#              "eval_bbs",
#              "eval_ebird",
#              "eval_grid",
#              "eval_combo",
#              ) 
# logical <- c(TRUE, 
#              
#              )
# 
# if(is.null(x)) params[[x]] <- TRUE

```

```{r specify-junk}
# save a list of elements we always want to keep in memory
# we also distinguish between the base argumensts for use later in making metadata tables describing our jags objects. 
args.save <- args.save.base <- c("args.save.base", ls()) 
```

# Step 2: Make a Spatial Grid
If the spatial grid R object, `grid.rds`, already exists in `r dir.proj.out`, load it into file. If not, will create a new spatial grid and save to file. 
```{r make-grid}
## If a grid.rds is saved in project directory, will not run script and instead will load that file into memory
## load in that rds.
if("grid.rds" %in% list.files(dir.spatial.out)) grid <- readRDS(paste0(dir.spatial.out, "/", "grid.rds"))else{
study.area <-
  rnaturalearth::ne_states(country = countries, returnclass = "sf") %>%
  # remove region(s)
  filter(tolower(name) %in% tolower(states)) %>%
  filter(!tolower(name) %in% tolower(region.remove)) %>%
  sf::st_transform(study.area, crs = crs.target)
# unique(study.area$adm0_a3) #should add a test here to make sure number of countries expected is grabbed.

# throw a grid over the study area layer
grid <- study.area %>%
  sf::st_make_grid(cellsize = grid.size,
               square = FALSE,
               flat_topped = TRUE) %>%
  sf::st_intersection(study.area) %>%
  # st_cast("MULTIPOLYGON") %>%
  sf::st_sf() %>%
  mutate(gridcellid = row_number()) %>%
  sf::st_transform(crs = crs.target)

# add the grid cell area as a variable
grid$area <- sf::st_area(grid)

# # Visualize to check
# tmap::qtm(grid)
# mapview::mapview(grid) # interactive, openstreetmap

# Add centroid lat lon to grid 
centroid.coords <- sf::st_coordinates(sf::st_geometry(sf::st_centroid(grid)))
grid$cell.lon.centroid <- centroid.coords[,1]
grid$cell.lat.centroid <- centroid.coords[,2]
grid$area <- st_area(grid)

# Export Data
saveRDS(grid, file = paste0(dir.spatial.out, "/", "grid.rds"))
}
# Clear junk
args.save <- junk_it(args.save, "grid")
```

# Step 3: Load or Create BBS and eBird Data
## Step 3a: Check to see if the munged spatial data files already exist.
If these files already exist, this will load in those files and skip steps 3b and 3c.
```{r spatial-files-load, include=FALSE}
## If all files do not exist, then something is may have gone awry in a previous session and we should be safe and re-create everything.
fns.spatial <- c("bbs_spatial.rds", "ebird_spatial.rds", "grid.rds")
if(all(fns.spatial %in% list.files(dir.spatial.out))){
  cat("importing bbs, ebird and grid sf objects.\n\n")
  fns.spatial   <- list.files(dir.spatial.out, full.names = TRUE)
  bbs_spatial   <- readRDS(fns.spatial[stringr::str_detect(fns.spatial, "bbs_spat")])
  grid          <- readRDS(fns.spatial[stringr::str_detect(fns.spatial, "grid")])
  ebird_spatial <- readRDS(fns.spatial[stringr::str_detect(fns.spatial, "ebird_spat")]) # sometimes this fails because ebird data hates me, so re-run plz
  ## If you want to check out the spatial grid wtih some basic BBS stats, go for it:
  if(params$browse.plots) browseURL(list.files(dir.plots, "bbs_spatial_exploratory.pdf", full.names=TRUE))# opens the PDF!
  }
```

## Step 3b: BBS Data Munging
Depending on the size of the study area, resolution of the grid cells, and whether you've already downloaded the BBS data, this may take a few minutes.
```{r bbs-munge}
# Do not run if bbs_spatial already exists
if(!exists("bbs_spatial")){
# Check for existing files ------------------------------------------------
fns <- list.files(dir.bbs.out)
fns.spatial <- list.files(dir.spatial.out)
if("bbs_spatial.rds" %in% tolower(fns.spatial)) bbs_spatial <- readRDS(paste0(dir.spatial.out, "/", "bbs_spatial.rds"))else{

# Munge BBS data ----------------------------------------------------------
## Import and/or Download BBS Observations and Metadata -----------------------------
#### Original observations data
if("bbs_orig.rds" %in% tolower(fns)){
  bbs_orig <-
    readRDS(paste0(dir.bbs.out, "/bbs_orig.rds"))
  } else{
      print("downloading the bbs data, this might take 45sec")
      bbs_orig <- grab_bbs_data(sb_dir = dir.bbs.out)
      saveRDS(bbs_orig, paste0(dir.bbs.out, "/bbs_orig.rds"))
}

#### Munged observations data
if (!"bbs_obs.rds" %in% tolower(fns)) {
  bbs_obs <-
    munge_bbs(
      list = bbs_orig,
      spp = interest.species,
      states=states,
      keep.stop.level.data = FALSE
    )
  saveRDS(bbs_obs, paste0(dir.bbs.out, "/bbs_obs.rds"))
} else{
  bbs_obs <- readRDS(paste0(dir.bbs.out, "/bbs_obs.rds"))
}
## Make BBS Spatial Layer ----------------------------------------------
# munges all routes at first then moves to subsetting to the grid, so have patience
# takes about a minute for 1-3 states
cat("Munging the BBS route shapefiles/spatial layer.\nIf `grid` specified, will take a hot minute.\n\n")
bbs_spatial <-
  make_bbs_spatial(
    bbs.obs = bbs_obs,
    cws.routes.dir = cws.routes.dir, #location of the CWS BBS routes shapefiles
    usgs.routes.dir = usgs.routes.dir, #location of the USGS BBS routes shapefiles
    crs.target = crs.target,
    routes.keep=unique(bbs_obs$RTENO), 
    grid=grid,
    keep.empty.cells =TRUE,
    plot.dir=dir.plots,
    overwrite=TRUE
  )

saveRDS(bbs_spatial, paste0(dir.spatial.out, "/bbs_spatial.rds"))
## View the file with basic bbs stats against the spatial grid
browseURL(list.files(dir.plots, "bbs_spatial_exploratory", full.names = TRUE))
}

args.save <- junk_it(args.save, "bbs_spatial")
}
```

## Step 3c: eBird Data Munging 
Due to the size of the eBird data, it may take many many minutes to munge the data. 
```{r ebird-data}
# Do not run if bbs_spatial already exists
if(!exists("ebird_spatial")){
if (parallel::detectCores() <= 4 |
    memory.limit() < 25000)
  warning(
    "You probably don't have enough RAM and/or CPU to munge the eBird data. Don't blame me if your machine crashes. If `filter_ebird_data` takes longer than 20 minutes, something is probably wrong.\n\n"
  )

fns.ebird <- id_ebird_files(dir.ebird.in = dir.ebird.in)

# Filter the eBird Data ---------------------------------------------------
ebird_filtered <- filter_ebird_data(
                                    fns.ebird = fns.ebird,
                                    overwrite = FALSE,
                                    dir.ebird.out = dir.ebird.out,
                                    countries = countries,
                                    states = states,
                                    protocol = c("Traveling","Stationary"),
                                    species = interest.species,
                                    max.num.observers=max.num.observers,
                                    years=year.range
                                    )

## Zero-fill the eBird Data -------------------------------------------------
# fns <- list.files(dir.ebird.out, full.names = TRUE, pattern = "filtered.txt")

# would like to get this functional but auk_zerofill currently requires
## VERY specific coltypes and names. not flexible in coltypes...
# ebird_zf <- auk::auk_zerofill(x=fns[fns %>% stringr::str_detect("obs")],
#                               sampling_events = fns[fns %>% stringr::str_detect("samp")])
ebird_zf <- zerofill_ebird(myList=ebird_filtered, overwrite=FALSE, dir.out=dir.ebird.out)

## Create the eBird Spatial Layer  -----------------------------------------------------
### need to add argument in make_ebird_spatial function to load in file if it exists...
### maybe also save to file inside that funciton 
ebird_spatial <- make_ebird_spatial(df=ebird_zf, crs.target = crs.target, grid = grid)

## Export eBird Spatial Data -------------------------------------------------------------
saveRDS(ebird_spatial, file = paste0(dir.spatial.out, "ebird_spatial.rds"))
# list.files(dir.spatial.out, "spatial.rds")
# remove junk ----------------------------------------------------------------------------
args.save <- junk_it(args.save, "ebird_spatial")

}
```

## Step 3d: Basic Tests
Just double-check the CRS on the spatial files. They all should be the same before we integrate. 
```{r test-crs}
if(!(sf::st_crs(grid)==sf::st_crs(bbs_spatial) & sf::st_crs(ebird_spatial)==sf::st_crs(grid)))stop("Warning. The ebird, bbs, and grid spatial layers are not in same projection and/or CRS.")

if(!all(grid$gridcellid %in% unique(c(ebird_spatial$gridcellid, bbs_spatial$gridcellid))))
  warning("Empty grid cells (no ebird or bbs data) are not represented in the bird data.\nShould make sure empty cells are added to bird data.")
```

# Step 4: Integrate the BBS and eBird Spatial Data
To ensure proper integration (or rather, use of all data in JAGS) we need to munge the ebird and bbs spatial data just a little bit. We first ensure column names map to each other, where appropriate (e.g., bird count, dates).
```{r match-colnames}
## Force BBS colnames to lowercase.
names(bbs_spatial) <- tolower(names(bbs_spatial))
bbs_spatial   <- match_col_names(bbs_spatial)
ebird_spatial <- match_col_names(ebird_spatial)
```

Next, munge the dates, times, julian dates, and days of year for each dataset such that we can properly align on the temporal dimension.
```{r munge-dates-times}
cat("managing dates and times of spatial objects")
# Dates ---------------------------------------------
### make julian dates
bbs_spatial$date <- lubridate::as_date(bbs_spatial$date)
ebird_spatial$date <- lubridate::as_date(ebird_spatial$date)
## base date for julian date
#### eventually will need to save this or export it somewhere, maybe add it to jags list idk
base.date <- min(c(bbs_spatial$date, ebird_spatial$date), na.rm=TRUE)
## make julian dates
bbs_spatial$julian <- julian(bbs_spatial$date, origin = base.date)
ebird_spatial$julian <- julian(as.Date(ebird_spatial$date), origin = base.date)
## make day of year
ebird_spatial$yday <- lubridate::yday(ebird_spatial$date)
bbs_spatial$yday <- lubridate::yday(bbs_spatial$date)

## Filter days of the year if specified
if(exists("yday")) ebird_spatial <- ebird_spatial %>%
  filter(yday >= min.yday & yday <= max.yday)
if(exists("yday")) ebird_spatial <- ebird_spatial %>%
  filter(yday >= min.yday & yday <= max.yday)

# Times ---------------------------------------------
### this is an ugly workaround and can be improved, including throwing the processes into
### the BBS and eBird munging functions but this is it for now.
bbs_spatial$starttime=hms::as_hms(as.POSIXct(bbs_spatial$starttime, format="%H%M"))
bbs_spatial$endtime=hms::as_hms(as.POSIXct(bbs_spatial$endtime, format="%H%M"))
ebird_spatial$time_observations_started=hms::as_hms(as.POSIXct(ebird_spatial$time_observations_started, format="%H:%M:%S"))
```

If you don't need local sunlight/rise/set times, specify `eval=FALSE` in this chunk. This process takes a while and sometimes crashes when computing on the ebird data. 
```{r munge-sunlight}
## eventually--need to move this into the munging phases so we dont have to continue to recalculate it...
# Sunlight/daylight/moonlight ---------------------------------------------
## here, data must have columns lat and lon. I took care of this in
## utils.R function `match_col_names()`
cat("calculating astronomical stats...yes, the astronomy definition.\n")
sunlight.keep <- c("dawn", "solarNoon", "sunrise","sunriseEnd")

bbs.sunlight <- suncalc::getSunlightTimes(data=bbs_spatial %>% distinct(date, lon, lat),
                                            keep = sunlight.keep)

## ebird is so large that I need to split up b/c calculating astronomical info takes forever.
## i'd like to use kit::funique, but cannot figure out how to do that with >1 columns.
### so, am resorting to this method.
x <- ebird_spatial %>% dplyr::select(date, lat, lon)
chunks <- parallel::splitIndices(nrow(x), 100)
for(i in seq_along(chunks)){
  if(i==1) ebird.sunlight <- NULL
  rows = as.data.frame(chunks[i])
  chunk.start = min(rows[1])
  chunk.end   = max(rows[1])
  dat = x[chunk.start:chunk.end, ]
  dat = suncalc::getSunlightTimes(data=dat,
                            keep = sunlight.keep)

  ebird.sunlight <- dplyr::bind_rows(ebird.sunlight,dat)
  rm(dat, chunk.end, chunk.start, rows)
}

### turn vars in sunlight.keep into time only (otherwise they are in YYYY-MM-DD HH-MM-SS; we need only HH-MM)
ebird.sunlight <- ebird.sunlight  %>%
  dplyr::mutate(across(sunlight.keep, hms::as_hms))
bbs.sunlight <- bbs.sunlight %>%
  dplyr::mutate(across(sunlight.keep, hms::as_hms))

# ### dates are a pain in my ass...fix them before attempting a join. will need to address this above somehwere...this is ridiculous
# str(bbs_spatial$date); str(bbs.sunlight$date)
# str(ebird_spatial$date); str(ebird.sunlight$date)

### add sunlight information to spatial datasets
bbs <- left_join(bbs_spatial, bbs.sunlight)
ebird <- left_join(ebird_spatial, ebird.sunlight)
```
Export all these spatially-referenced data to a folder for quick use in JAGS data munging activities.
```{r export-munged-data}
saveRDS(bbs, file=paste0(dir.jags, "bbs.rds"))
saveRDS(grid, file=paste0(dir.jags, "grid.rds"))
saveRDS(ebird, file=paste0(dir.jags, "ebird.rds"))
args.save <- junk_it(args.save, c("bbs","grid","ebird"))
```

