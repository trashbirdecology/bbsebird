---
title: "Munge eBird and BBS Data for Integrated Model"
params:
    fn.munging: "1_data-munging.rmd"
    fn.setup:   "0_setup.rmd"
    fn.jdat:    "jdat"
    drop.nas: TRUE # TRUE = drop values where no observations data exists
---

# Step 1: Setup 
 This chunk sources some redundant chunks in the data-munging r markdown
```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  message = TRUE, 
  echo=FALSE, 
  warning=FALSE, 
  tidy=TRUE, 
  include=FALSE
)
setup.chunk.needed<-FALSE
temp=tempfile(fileext=".R")
knitr::purl(params$fn.setup, output=temp)
source(temp)
```

Importing the munged data
```{r import-munged-data}
# Filenames for munged data
fns <- list.files(dir.jags, full.names=TRUE)
# These files are all sf (spatial data objs)
ebird.spatial <- readRDS(fns[str_detect(fns, "ebird.rds")])
bbs.spatial <- readRDS(fns[str_detect(fns, "bbs.rds")])
grid.spatial <- readRDS(fns[str_detect(fns, "grid.rds")])
# Convert to non-sf objects
bbs <- st_drop_geometry(bbs.spatial) %>% 
  arrange(gridcellid, rteno, year)
ebird <- st_drop_geometry(ebird.spatial)%>% 
  arrange(gridcellid, checklist_id, year)
grid <- st_drop_geometry(grid.spatial)

# Specify junk to keep later on 
args.save <- junk_it(args.save, c("bbs","grid","ebird",                                "bbs.spatial","grid.spatial","ebird.spatial",
                                  ".trim"))
```

Evaluate parameter logicals
```{r eval-params}
if(!"drop.nas" %in% names(params)) params$drop.nas <- TRUE
if(params$drop.nas){
  bbs   <- bbs %>% filter(!is.na(C)) %>% as.data.frame()
  ebird <- ebird %>% filter(!is.na(C)) %>% as.data.frame()
}
```

# Step 2: BBS Data
## Make and scale detection covariates
```{r bbs-scale-vars}
bbs <- bbs %>%
  ### create a variable for the wind "average"
  group_by(rteno, year) %>%
  mutate(windmean = abs(startwind-endwind)/2) %>%
  ungroup() %>% 
  ### z-scale covariates
  mutate(
    wind.z = (windmean - mean(windmean, na.rm=TRUE))/sd(windmean, na.rm=TRUE),
    noise.z = (noisemean - mean(noisemean, na.rm=TRUE))/sd(noisemean, na.rm=TRUE),
    car.z = (carmean - mean(carmean, na.rm=TRUE))/sd(carmean, na.rm=TRUE)
  ) 

# bbs <- bbs %>%
#   ### weighted counts by prop route in cell and cell area
#   mutate(C.weighted.by.proparea.in.cell = as.numeric(C*proprouteincell/area)) # weighted C per grid area (# per m^2)
```

```{r bbs-y-and-indexing}
## Observed counts as 3D array (dims: rteno by year by gridcellid)
yBBS.grid   <- make_array(bbs, val="C")
## Observed counts as 2D matrix (dims: rteno by year)
yBBS.site   <- make_mat(bbs %>% distinct(rteno, year, C), row = "rteno", col="year", val = "C")

### vectors comprising site, cell, and year identities
site.ids.bbs   <- dimnames(yBBS.grid)[1] %>% unlist() %>% as.factor()#sites=rteno
year.ids.bbs   <- dimnames(yBBS.grid)[2] %>% unlist() %>% as.integer()#years
grid.ids.bbs   <- dimnames(yBBS.grid)[3] %>% unlist() %>% as.numeric()#gridcellid
### indexes associated with id vectors for site, cell, and year
site.ind.bbs     <- 1:dim(yBBS.grid)[1]
year.ind.bbs     <- 1:dim(yBBS.grid)[2]
grid.ind.bbs     <- 1:dim(yBBS.grid)[3]

S.bbs <- length(site.ind.bbs)# num sites
T.bbs <- length(year.ind.bbs)# num T
G.bbs <- length(grid.ind.bbs)# num grid cells

sites.bbs <- data.frame(site.id=site.ids.bbs, ind=site.ind.bbs)
years.bbs <- data.frame(year.id=year.ids.bbs, year.ind=year.ind.bbs)
## for estimating lambda.grid, we need to know
  ### which grid cells each route runs through, and be
  ### able to easily index within that route (site) and grid cells (grid)
bbs.index <- which(!is.na(yBBS.grid), arr.ind=TRUE, useNames=TRUE)
colnames(bbs.index) <- c("site", "year", "grid")# rteno, year, gridcellid
```

Create matrices for route-grid relationships and descriptors
```{r bbs-mats-spatial}
## Linear model covariates will be 2-D since, currently, no changes over time. 
grid.bbs <- bbs %>% distinct(gridcellid, rteno, .keep_all=TRUE) %>% units::drop_units()
area.bbs <-  make_mat(grid.bbs, val="area")
prop.site.in.cell.bbs <- make_mat(grid.bbs, val="proprouteincell")
```

Arrays comprising detection covariate observations
```{r bbs-p-covar-arrays}
p.bbs.wind    <- make_array(bbs, val="wind.z")
p.bbs.cars    <- make_array(bbs, val="car.z")
p.bbs.noise   <- make_array(bbs, val="noise.z")
p.bbs.yday   <- make_array(bbs, val="yday")
p.bbs.jday   <- make_array(bbs, val="julian")
p.bbs.obsfirstyearbbs     <- make_array(bbs, val="obsfirstyearbbs")
p.bbs.obsfirstyearroute   <- make_array(bbs, val="obsfirstyearroute")
## need to add conversion of temperatures to C or F in data munging scripts!!!
```

Specify desired inputs into JAGS data output for BBS 
```{r names.bbs}
names.bbs <- c(
 # route-level detection covariates # keep the ones we actually need
 # 'p.bbs.wind', 
 # 'p.bbs.cars', 
 # 'p.bbs.noise', 
 # 'p.bbs.yday', 
 # 'p.bbs.jday', 
 # 'p.bbs.obsfirstyearbbs',
 # 'p.bbs.obsfirstyearroute',
 # for indexing
 'site.ids.bbs', 'year.ids.bbs', 'grid.ids.bbs',  ## identities
 'site.ind.bbs', 'year.ind.bbs', 'grid.ind.bbs',  ## indexing on identities
 # count data
 'yBBS.grid', # at the grid-level (replicate counts where multiple rteno in a single grid.)
 'yBBS.site',# at the route-level
 # route-grid information
 "prop.site.in.cell.bbs", 
 # grid cell covariates
 "area.bbs",
 # indexing
 ## loop length indexes
 "S.bbs", "T.bbs", "G.bbs", 
 ## yBBS array location index 
 "bbs.index" 
)
```

# Step 3: eBird Data
```{r ebird-obs}
ebird %>% head()


```



# Step 4: Grid Shit

# Step 5: Wrap it All Up 
```{r make-jdat}
### use get_data_structure(listname ) to produce a talbe metadata. 
## use make_jags_list() to create a jdat list from:
# c(names.bbs, names.grid, names.ebird)
jdat <- make_jags_list(c(names.bbs))
# Save to file..
saveRDS(jdat, file = paste0(dir.jags,params$fn.jdat, ".RDS"))
```

